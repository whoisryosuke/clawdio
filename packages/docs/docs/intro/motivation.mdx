---
sidebar_position: 3
---

# Motivation

This library was created to simplify the process of leveraging WASM inside of Audio Worklets.

## Why WASM?

You might ask yourself: is it really more efficient to take a whole other language, compile it down to bits, and run that inside of JavaScript? And I’d say: in some cases actually yeah.

### Garbage free since 2023

The problem with JavaScript is that it’s not the most memory efficient language. It’s designed to be dynamic and easy to use, so you don’t have to think about finer details like allocating memory.

To handle this, JavaScript has something called a “[**garbage collector**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Memory_management#garbage_collection)”, where any unused data gets released regularly, allowing us to allocate more as needed (and prevent us from overloading or leaking too much memory).

But when we run WASM code, [it doesn’t have a garbage collector](https://github.com/WebAssembly/gc/issues/36), since we write it in a language that allocates the exact amount of memory needed at all times ([only recently was it added](https://developer.chrome.com/blog/wasmgc) for supporting GC based languages like PHP). That allows us to run the same simple functions (like taking integers and adding or multiplying them together) and it makes it much faster.

This makes a bigger difference when you consider how we process audio. When we analyze audio, we’re often observing a constant stream of data. And we’re talking a lot of data — often arrays of 1000s of items at a time and looping over each of them. Any performance we can save with those “low level” processes, it’d be nice.

### Reusability

You might not be aware, but [most audio code](https://github.com/BillyDM/awesome-audio-dsp/blob/main/sections/OPEN_SOURCE_PLUGINS_AND_SOFTWARE.md) isn’t written in JavaScript. It’s usually written in a low level language like C++, maybe Python at the most. This is because C++ (and other languages like Rust) are much better at processing large amounts of data more efficiently.

And to be honest, C and C++ have been around the longest, so their ecosystem is the most mature. You’ll find that most Rust modules are wrappers around existing C libraries.

So to be able to leverage that ecosystem and other libraries is incredibly valuable, instead of having to convert their code to JavaScript (and hope it’s nearly as efficient).
